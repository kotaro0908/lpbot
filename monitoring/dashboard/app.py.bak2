# monitoring/dashboard/app.py
from flask import Flask, render_template, request, jsonify, redirect, url_for
import sqlite3
from datetime import datetime, timedelta
import json
import os
import sys
import requests
from web3 import Web3
import math

# プロジェクトルートをパスに追加
sys.path.append('/root/lpbot')

app = Flask(__name__)
app.config['SECRET_KEY'] = os.urandom(24)

# データベースパス
DB_PATH = '/root/lpbot/monitoring/lpbot.db'

# 既存のWeb3設定を使用
RPC_URL = os.getenv("RPC_URL", "https://arb1.arbitrum.io/rpc")
WETH_ADDRESS = "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1"
USDC_ADDRESS = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831"
POOL_ADDRESS = "0xC6962004f452bE9203591991D15f6b388e09E8D0"

# The Graph API設定
GRAPH_API_URL = "https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v3-arbitrum"

# Web3接続
w3 = Web3(Web3.HTTPProvider(RPC_URL))

# ERC20 ABI（残高取得用）
ERC20_ABI = [
    {
        "inputs": [{"internalType": "address", "name": "account", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
        "stateMutability": "view",
        "type": "function"
    }
]


def get_db_connection():
    """データベース接続"""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


@app.route('/')
def index():
    """メインダッシュボード"""
    return render_template('index.html')


@app.route('/investment')
def investment():
    """投資履歴管理ページ"""
    return render_template('investment.html')


@app.route('/api/investment', methods=['GET', 'POST'])
def api_investment():
    """投資履歴API"""
    if request.method == 'POST':
        # 新規投資記録を追加
        data = request.json
        conn = get_db_connection()

        conn.execute("""
                     INSERT INTO investment_history
                         (timestamp, action, amount_usd, note)
                     VALUES (?, ?, ?, ?)
                     """, (
                         data['date'],
                         data['action'],
                         float(data['amount']),
                         data.get('note', '')
                     ))

        # 累計投資額を更新
        update_cumulative_investment(conn)
        conn.commit()
        conn.close()

        return jsonify({'status': 'success'})

    else:
        # 投資履歴を取得
        conn = get_db_connection()
        history = conn.execute("""
                               SELECT *
                               FROM investment_history
                               ORDER BY timestamp DESC
                               """).fetchall()
        conn.close()

        return jsonify([dict(row) for row in history])


def update_cumulative_investment(conn):
    """累計投資額を更新"""
    rows = conn.execute("""
                        SELECT timestamp, action, amount_usd
                        FROM investment_history
                        ORDER BY timestamp
                        """).fetchall()

    cumulative = 0
    for row in rows:
        if row['action'] == 'deposit':
            cumulative += row['amount_usd']
        elif row['action'] == 'withdraw':
            cumulative -= row['amount_usd']

        conn.execute("""
                     UPDATE investment_history
                     SET cumulative_investment = ?
                     WHERE timestamp = ? AND action = ? AND amount_usd = ?
                     """, (cumulative, row['timestamp'], row['action'], row['amount_usd']))


def ticks_to_price_range(lower_tick, upper_tick):
    """ティックを価格レンジに変換"""
    try:
        # tick to price: price = 1.0001^tick * (10^6 / 10^18)
        lower_price = math.pow(1.0001, lower_tick) * (10 ** 12)
        upper_price = math.pow(1.0001, upper_tick) * (10 ** 12)

        # レンジ幅の計算
        range_width = ((upper_price - lower_price) / ((upper_price + lower_price) / 2)) * 100

        return {
            'lower_price': lower_price,
            'upper_price': upper_price,
            'range_width_percent': range_width
        }
    except Exception as e:
        print(f"価格変換エラー: {e}")
        return {
            'lower_price': 0,
            'upper_price': 0,
            'range_width_percent': 0
        }

def calculate_in_range_percent():
    """過去24時間のレンジ内滞在率を計算"""
    # TODO: 実装が必要
    # 現在は仮の値を返す
    return 85.5  # 85.5%という意味


def format_timestamp(timestamp_str):
    """タイムスタンプを見やすい形式に変換"""
    try:
        if timestamp_str:
            # ISO形式のタイムスタンプをパース
            dt = datetime.fromisoformat(timestamp_str.replace('T', ' ').split('.')[0])
            # YYYY/MM/DD HH:MM:SS形式に変換
            return dt.strftime('%Y/%m/%d %H:%M:%S')
    except:
        pass
    return timestamp_str


@app.route('/api/dashboard_data')
def api_dashboard_data():
    """ダッシュボード用データAPI"""
    conn = get_db_connection()

    # 現在の総資産価値（修正版）
    eth_price = get_current_eth_price()
    balances = get_wallet_balances()
    wallet_value = (balances['eth'] + balances['weth']) * eth_price + balances['usdc']
    lp_value = get_lp_position_value(eth_price)
    total_value = wallet_value + lp_value

    # NFT IDを取得
    current_nft = get_current_nft_id()
    print(f"API: 現在のNFT ID = {current_nft}")

    # 累計収益
    total_fees = conn.execute("""
                              SELECT COALESCE(SUM(total_usd), 0) as total
                              FROM fee_collection_history
                              """).fetchone()['total']

    # 累計ガス代
    total_gas = conn.execute("""
                             SELECT COALESCE(SUM(gas_cost_usd), 0) as total
                             FROM rebalance_history
                             """).fetchone()['total']

    # 投資額
    investment = conn.execute("""
                              SELECT COALESCE(cumulative_investment, 0) as total
                              FROM investment_history
                              ORDER BY timestamp DESC
                                  LIMIT 1
                              """).fetchone()

    total_investment = investment['total'] if investment else 0

    # リバランス統計を追加（修正版）
    rebalance_stats = conn.execute("""
                                   SELECT
                                       -- 実際のリバランス回数（range_outのみ）
                                       COUNT(DISTINCT CASE
                                                          WHEN new_nft_id IS NOT NULL AND reason = 'range_out'
                                                              THEN old_nft_id || '->' || new_nft_id END)        as unique_transitions,

                                       -- 今月のリバランス回数
                                       COUNT(DISTINCT CASE
                                                          WHEN new_nft_id IS NOT NULL AND reason = 'range_out'
                                                              AND DATE (timestamp, 'start of month') = DATE
                                             ('now', 'start of month')
                                             THEN old_nft_id || '->' || new_nft_id
                                             END)                                                               as month_transitions,

                                       -- 今日のリバランス回数
                                       COUNT(CASE WHEN DATE (timestamp) = DATE ('now', 'localtime') THEN 1 END) as today_attempts,

                                       -- 全体の試行回数
                                       COUNT(*)                                                                 as total_attempts,

                                       -- 成功率用
                                       COUNT(CASE WHEN success = 1 AND new_nft_id IS NOT NULL THEN 1 END)       as success_count
                                   FROM rebalance_history
                                   """).fetchone()

    # 成功率計算
    success_rate = 0
    if rebalance_stats and rebalance_stats['total_attempts'] > 0:
        success_rate = (rebalance_stats['success_count'] / rebalance_stats['total_attempts']) * 100

    # 現在のレンジ情報
    current_range = None
    if current_nft:
        range_info = conn.execute("""
                                  SELECT new_tick_lower, new_tick_upper
                                  FROM rebalance_history
                                  WHERE new_nft_id = ?
                                  ORDER BY timestamp DESC
                                      LIMIT 1
                                  """, (current_nft,)).fetchone()

        if range_info:
            price_range = ticks_to_price_range(range_info['new_tick_lower'], range_info['new_tick_upper'])
            current_range = {
                'lower': price_range['lower_price'],
                'upper': price_range['upper_price'],
                'width': price_range['range_width_percent']
            }

    # 最終リバランス時刻
    last_rebalance = conn.execute("""
                                  SELECT timestamp
                                  FROM rebalance_history
                                  WHERE success = 1
                                  ORDER BY timestamp DESC
                                      LIMIT 1
                                  """).fetchone()

    # レンジ内滞在率
    in_range_percent = calculate_in_range_percent()

    # 今日の収益（追加）
    today_fees = conn.execute("""
                              SELECT COALESCE(SUM(total_usd), 0) as total
                              FROM fee_collection_history
                              WHERE DATE (timestamp) = DATE ('now', 'localtime')
                              """).fetchone()['total']

    conn.close()

    return jsonify({
        'total_value': total_value,
        'lp_value': lp_value,
        'wallet_value': wallet_value,
        'total_investment': total_investment,
        'total_fees': total_fees,
        'total_gas': total_gas,
        'net_profit': total_fees - total_gas,
        'roi': ((total_value - total_investment) / total_investment * 100) if total_investment > 0 else 0,
        'current_nft': current_nft,
        'rebalance_today': rebalance_stats['today_attempts'] if rebalance_stats else 0,
        'rebalance_count': rebalance_stats['unique_transitions'] if rebalance_stats else 0,
        'rebalance_attempts': rebalance_stats['total_attempts'] if rebalance_stats else 0,
        'month_rebalances': rebalance_stats['month_transitions'] if rebalance_stats else 0,
        'success_rate': success_rate,
        'current_range': current_range,
        'last_rebalance': format_timestamp(last_rebalance['timestamp']) if last_rebalance else None,
        'in_range_time_percent': in_range_percent,
        'today_fees': today_fees
    })


def get_current_eth_price():
    """現在のETH価格を取得（プールコントラクトから直接）"""
    try:
        from web3 import Web3

        # Web3接続
        w3 = Web3(Web3.HTTPProvider(os.getenv('RPC_URL', 'https://arb1.arbitrum.io/rpc')))

        # Uniswap V3 USDC/WETH プール
        POOL_ADDRESS = Web3.to_checksum_address("0xC6962004f452bE9203591991D15f6b388e09E8D0")

        # Pool ABI (slot0のみ)
        pool_abi = [{
            "inputs": [],
            "name": "slot0",
            "outputs": [
                {"internalType": "uint160", "name": "sqrtPriceX96", "type": "uint160"},
                {"internalType": "int24", "name": "tick", "type": "int24"}
            ],
            "stateMutability": "view",
            "type": "function"
        }]

        pool = w3.eth.contract(address=POOL_ADDRESS, abi=pool_abi)
        slot0 = pool.functions.slot0().call()
        sqrt_price_x96 = slot0[0]

        # 価格計算
        price = (sqrt_price_x96 / (2 ** 96)) ** 2
        eth_price_usd = price * (10 ** 12)  # USDC decimals adjustment

        print(f"ETH価格取得成功: ${eth_price_usd:.2f}")
        return eth_price_usd

    except Exception as e:
        print(f"ETH価格取得エラー: {e}")
        return 3800.0  # フォールバック


def get_wallet_balances():
    """ウォレット残高取得"""
    try:
        # ウォレットアドレス取得
        wallet_address = os.getenv("WALLET_ADDRESS")
        if not wallet_address:
            print("WALLET_ADDRESS環境変数が設定されていません")
            return {'eth': 0, 'weth': 0, 'usdc': 0}

        # ETH残高
        eth_balance = w3.eth.get_balance(wallet_address)
        eth_amount = eth_balance / 10 ** 18

        # WETH残高
        weth_contract = w3.eth.contract(address=WETH_ADDRESS, abi=ERC20_ABI)
        weth_balance = weth_contract.functions.balanceOf(wallet_address).call()
        weth_amount = weth_balance / 10 ** 18

        # USDC残高
        usdc_contract = w3.eth.contract(address=USDC_ADDRESS, abi=ERC20_ABI)
        usdc_balance = usdc_contract.functions.balanceOf(wallet_address).call()
        usdc_amount = usdc_balance / 10 ** 6

        return {
            'eth': eth_amount,
            'weth': weth_amount,
            'usdc': usdc_amount
        }

    except Exception as e:
        print(f"ウォレット残高取得エラー: {e}")
        return {'eth': 0, 'weth': 0, 'usdc': 0}


def get_current_nft_id():
    """現在のNFT IDを取得"""
    try:
        # 絶対パスで指定
        json_path = '/root/lpbot/tracked_nfts.json'

        with open(json_path, 'r') as f:
            data = json.load(f)
            nft_ids = data.get('nft_ids', [])
            current_nft = nft_ids[-1] if nft_ids else None
            return current_nft

    except Exception as e:
        print(f"NFT ID読み込みエラー: {e}")
        return None


def get_lp_position_value(eth_price):
    """現在のLPポジション価値を取得"""
    try:
        # Position Manager Contract
        POSITION_MANAGER = "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"

        # 現在のNFT ID取得
        current_nft_id = get_current_nft_id()
        if not current_nft_id:
            print("NFT IDが見つかりません")
            return 0

        # Position Manager ABI (positions関数のみ)
        position_abi = [{
            "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
            "name": "positions",
            "outputs": [
                {"internalType": "uint96", "name": "nonce", "type": "uint96"},
                {"internalType": "address", "name": "operator", "type": "address"},
                {"internalType": "address", "name": "token0", "type": "address"},
                {"internalType": "address", "name": "token1", "type": "address"},
                {"internalType": "uint24", "name": "fee", "type": "uint24"},
                {"internalType": "int24", "name": "tickLower", "type": "int24"},
                {"internalType": "int24", "name": "tickUpper", "type": "int24"},
                {"internalType": "uint128", "name": "liquidity", "type": "uint128"},
                {"internalType": "uint256", "name": "feeGrowthInside0LastX128", "type": "uint256"},
                {"internalType": "uint256", "name": "feeGrowthInside1LastX128", "type": "uint256"},
                {"internalType": "uint128", "name": "tokensOwed0", "type": "uint128"},
                {"internalType": "uint128", "name": "tokensOwed1", "type": "uint128"}
            ],
            "stateMutability": "view",
            "type": "function"
        }]

        # ポジション情報取得
        position_manager = w3.eth.contract(address=POSITION_MANAGER, abi=position_abi)
        position = position_manager.functions.positions(int(current_nft_id)).call()

        liquidity = position[7]

        if liquidity == 0:
            print("ポジションに流動性がありません")
            return 0

        # 現在価格でのポジション価値を簡易計算
        # TODO: より正確な計算（tick範囲を考慮）を実装
        # 暫定的に流動性の大きさから推定
        estimated_value = float(liquidity) / 10 ** 15 * eth_price * 0.5

        print(f"LP価値推定: ${estimated_value:.2f} (NFT: {current_nft_id})")
        return estimated_value

    except Exception as e:
        print(f"LPポジション価値取得エラー: {e}")
        return 0

def calculate_total_value():
    """現在の総資産価値を計算（実装版）"""
    try:
        # ETH価格取得
        eth_price = get_current_eth_price()

        # ウォレット残高取得
        balances = get_wallet_balances()

        # ウォレット価値計算
        wallet_value = (balances['eth'] + balances['weth']) * eth_price + balances['usdc']

        # NFTポジション価値（暫定的にウォレット価値を使用）
        # TODO: 将来的にはNFTの実際のポジション価値を計算
        total_value = wallet_value

        print(f"総資産価値計算完了: ${total_value:.2f}")
        print(f"  ETH価格: ${eth_price:.2f}")
        print(f"  ETH: {balances['eth']:.4f}, WETH: {balances['weth']:.4f}, USDC: {balances['usdc']:.2f}")

        return total_value

    except Exception as e:
        print(f"総資産価値計算エラー: {e}")
        return 12450.23  # エラー時はダミー値を返す


if __name__ == '__main__':
    # まず投資履歴テーブルを作成
    conn = get_db_connection()
    conn.execute("""
                 CREATE TABLE IF NOT EXISTS investment_history
                 (
                     id
                     INTEGER
                     PRIMARY
                     KEY
                     AUTOINCREMENT,
                     timestamp
                     DATETIME
                     NOT
                     NULL,
                     action
                     TEXT
                     NOT
                     NULL,
                     amount_usd
                     REAL
                     NOT
                     NULL,
                     cumulative_investment
                     REAL,
                     note
                     TEXT,
                     created_at
                     DATETIME
                     DEFAULT
                     CURRENT_TIMESTAMP
                 )
                 """)

    # fee_collection_historyテーブルも作成
    conn.execute("""
                 CREATE TABLE IF NOT EXISTS fee_collection_history
                 (
                     id
                     INTEGER
                     PRIMARY
                     KEY
                     AUTOINCREMENT,
                     timestamp
                     DATETIME
                     NOT
                     NULL,
                     nft_id
                     INTEGER,
                     tx_hash
                     TEXT,
                     amount0
                     REAL,
                     amount1
                     REAL,
                     amount0_usd
                     REAL,
                     amount1_usd
                     REAL,
                     total_usd
                     REAL,
                     gas_used
                     INTEGER,
                     gas_cost_eth
                     REAL,
                     gas_cost_usd
                     REAL,
                     net_profit_usd
                     REAL,
                     created_at
                     DATETIME
                     DEFAULT
                     CURRENT_TIMESTAMP
                 )
                 """)

    conn.commit()
    conn.close()

    app.run(host='0.0.0.0', port=5000, debug=True)